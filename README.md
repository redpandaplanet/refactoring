# refactoring

```javascript
//Данная функция в параметре s принимает строку
//А в параметра a и b символы
//Затем с конца посимвольно проходит по строке до первого символа (не включая его)
//И в случае совпадения возвращает индекс первого с конца символа совпавшего с одним(или двумя) из параметров
//Если совпадения не найдено, возвращается -1
function func(s, a, b) {
	//Регулярным выражением проверяем строку на пустоту
	if (s.match(/^$/)) {
		return -1;
	}

	//Непонятно зачем первый символ строки исключается из сравнения
	var i = s.length -1;
	var aIndex =     -1;
	var bIndex =     -1;

	//Выходим из цикла как только найдено хотя бы одно совпадение с параметрами a или b в строке
	while ((aIndex == -1) && (bIndex == -1) && (i > 0)) {
		//Идём с конца строки и сравниваем с параметром a
		//Если символ совпадает с параметром a записываем его в aIndex
	    if (s.substring(i, i +1) == a) {
	    	aIndex = i;
    	}
		//Идём с конца строки и сраваниваем с параметром b
		//Если символ совпадает с параметром b записываем его в bIndex
	    if (s.substring(i, i +1) == b) {
	    	bIndex = i;
    	}
	    i = i - 1;
	}
	
	//Если aIndex не равен -1, т.е. параметр a найден в строке
	if (aIndex != -1) {
		//В этом условии нет смысла, т.к. если aIndex найден, то bIndex либо равен -1
	    if (bIndex == -1) {
	        return aIndex;
	    }
	    //Либо bIndex равен aIndex, т.к. найдены на одном витке цикла, а значит символы в параметрах a и b равны
	    else {
	    	//Т.о. большее из них тоже искать смысла не имеет
	        return Math.max(aIndex, bIndex);
	    }
	}

	if (bIndex != -1) {
	    return bIndex;
	}
	else {
	    return -1;
	}
}
```

```javascript
function funcNew(s, a, b) {
	//Проверяем, передана ли в параметре s строка и не пустая ли она
	//Конструкция typeof работает быстрей, чем регулярное выражение
	//И не вызывает TypeError, если в параметре s передана не строка
	if (typeof s != 'string' && s.length < 1) {
		return -1;
	}

	var stringLength = s.length -1;
	var currentChar = '';

	//Заменяем цикл while на цикл for
	//Т.к. while больше подходит, когда количество итераций неизвестно
	//Здесь же количество итераций ограничено длиной строки
	for (var i = stringLength;i > 0; i--) {
		//Сокращаем код от ненужных условий
		//Как только находим совпадение, возвращаем индекс символа
		currentChar = s.charAt(i)
		if (currentChar == a || currentChar == b) {
			return i;
		}
	}
	return -1
}
```

```javascript
//Более изящное сокращение вообще без цикла, но менее наглядное
function funcNewShort() {
	if (typeof s != 'string' && s.length < 1) {
		return -1;
	}
	var index = Math.max(str.lastIndexOf(a), str.lastIndexOf(b));
	//Если индекс сопадения равен 0, то по условию вернётся -1
	return index ? index : -1;
}
```
